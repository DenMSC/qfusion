/*
* R_GLSLBuildDeformv
*
* Converts some of the Q3A vertex deforms to a GLSL vertex shader.
* Supported deforms are: wave, move, bulge.
* NOTE: Autosprite deforms can only be performed in a geometry shader.
* NULL is returned in case an unsupported deform is passed.
*/
static const char *R_GLSLBuildDeformv( const deformv_t *deformv, int numDeforms ) {
	program[0] = '\0';
	Q_strncpyz( program,
				"#define QF_APPLY_DEFORMVERTS\n"
				"#if defined(APPLY_AUTOSPRITE) || defined(APPLY_AUTOSPRITE2)\n"
				"qf_attribute vec4 a_SpritePoint;\n"
				"#else\n"
				"#define a_SpritePoint vec4(0.0)\n"
				"#endif\n"
				"\n"
				"#if defined(APPLY_AUTOSPRITE2)\n"
				"qf_attribute vec4 a_SpriteRightUpAxis;\n"
				"#else\n"
				"#define a_SpriteRightUpAxis vec4(0.0)\n"
				"#endif\n"
				"\n"
				"void QF_DeformVerts(inout vec4 Position, inout vec3 Normal, inout vec2 TexCoord)\n"
				"{\n"
				"float t = 0.0;\n"
				"vec3 dist;\n"
				"vec3 right, up, forward, newright;\n"
				"\n"
				"#if defined(WAVE_SIN)\n"
				, sizeof( program ) );

	for( i = 0; i < numDeforms; i++, deformv++ ) {
		switch( deformv->type ) {
			case DEFORMV_AUTOSPRITE:
				Q_strncatz( program,
							"right = (1.0 + step(0.5, TexCoord.s) * -2.0) * u_ViewAxis[1];\n;"
							"up = (1.0 + step(0.5, TexCoord.t) * -2.0) * u_ViewAxis[2];\n"
							"forward = -1.0 * u_ViewAxis[0];\n"
							"Position.xyz = a_SpritePoint.xyz + (right + up) * a_SpritePoint.w;\n"
							"Normal.xyz = forward;\n"
							"TexCoord.st = vec2(step(0.5, TexCoord.s),step(0.5, TexCoord.t));\n",
							sizeof( program ) );
				break;
			case DEFORMV_AUTOPARTICLE:
				Q_strncatz( program,
							"right = (1.0 + TexCoord.s * -2.0) * u_ViewAxis[1];\n;"
							"up = (1.0 + TexCoord.t * -2.0) * u_ViewAxis[2];\n"
							"forward = -1.0 * u_ViewAxis[0];\n"
				            // prevent the particle from disappearing at large distances
							"t = dot(a_SpritePoint.xyz + u_EntityOrigin - u_ViewOrigin, u_ViewAxis[0]);\n"
							"t = 1.5 + step(20.0, t) * t * 0.006;\n"
							"Position.xyz = a_SpritePoint.xyz + (right + up) * t * a_SpritePoint.w;\n"
							"Normal.xyz = forward;\n",
							sizeof( program ) );
				break;
			case DEFORMV_AUTOSPRITE2:
				Q_strncatz( program,
				            // local sprite axes
							"right = QF_LatLong2Norm(a_SpriteRightUpAxis.xy);\n"
							"up = QF_LatLong2Norm(a_SpriteRightUpAxis.zw);\n"

				            // mid of quad to camera vector
							"dist = u_ViewOrigin - u_EntityOrigin - a_SpritePoint.xyz;\n"

				            // filter any longest-axis-parts off the camera-direction
							"forward = normalize(dist - up * dot(dist, up));\n"

				            // the right axis vector as it should be to face the camera
							"newright = cross(up, forward);\n"

				            // rotate the quad vertex around the up axis vector
							"t = dot(right, Position.xyz - a_SpritePoint.xyz);\n"
							"Position.xyz += t * (newright - right);\n"
							"Normal.xyz = forward;\n",
							sizeof( program ) );
				break;
			default:
				return NULL;
		}
	}

	Q_strncatz( program,
				"#endif\n"
				"}\n"
				"\n"
				, sizeof( program ) );

	return program;
}

/*
* RP_UpdateBlendMixUniform
*
* The first component corresponds to RGB, the second to ALPHA.
* Whenever the program needs to scale source colors, the mask needs
* to be used in the following manner:
* color *= mix(vec4(1.0), vec4(scale), u_BlendMix.xxxy);
*/
void RP_UpdateBlendMixUniform( int elem, vec2_t blendMix ) {
	glsl_program_t *program = r_glslprograms + elem - 1;

	if( program->loc.BlendMix >= 0 ) {
		glUniform2fv( program->loc.BlendMix, 1, blendMix );
	}
}
