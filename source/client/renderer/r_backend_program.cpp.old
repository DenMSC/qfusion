/*
* RB_ApplyTCMods
*/
void RB_ApplyTCMods( const shaderpass_t *pass, mat4_t result ) {
	unsigned i;
	const float *table;
	double t1, t2, sint, cost;
	mat4_t m1, m2;
	const tcmod_t *tcmod;

	for( i = 0, tcmod = pass->tcmods; i < pass->numtcmods; i++, tcmod++ ) {
		switch( tcmod->type ) {
			case TC_MOD_ROTATE:
				cost = tcmod->args[0] * rb.currentShaderTime;
				sint = RB_FastSin( cost );
				cost = RB_FastSin( cost + 0.25 );
				m2[0] =  cost, m2[1] = sint, m2[12] =  0.5f * ( sint - cost + 1 );
				m2[4] = -sint, m2[5] = cost, m2[13] = -0.5f * ( sint + cost - 1 );
				Matrix4_Copy2D( result, m1 );
				Matrix4_Multiply2D( m2, m1, result );
				break;
			case TC_MOD_SCALE:
				Matrix4_Scale2D( result, tcmod->args[0], tcmod->args[1] );
				break;
			case TC_MOD_TURB:
				t1 = ( 1.0 / 4.0 );
				t2 = tcmod->args[2] + rb.currentShaderTime * tcmod->args[3];
				Matrix4_Scale2D( result,
								 1 + ( tcmod->args[1] * RB_FastSin( t2 ) + tcmod->args[0] ) * t1,
								 1 + ( tcmod->args[1] * RB_FastSin( t2 + 0.25 ) + tcmod->args[0] ) * t1 );
				break;
			case TC_MOD_STRETCH:
				table = RB_TableForFunc( tcmod->args[0] );
				t2 = tcmod->args[3] + rb.currentShaderTime * tcmod->args[4];
				t1 = FTABLE_EVALUATE( table, t2 ) * tcmod->args[2] + tcmod->args[1];
				t1 = t1 ? 1.0f / t1 : 1.0f;
				t2 = 0.5f - 0.5f * t1;
				Matrix4_Stretch2D( result, t1, t2 );
				break;
			case TC_MOD_SCROLL:
				t1 = tcmod->args[0] * rb.currentShaderTime;
				t2 = tcmod->args[1] * rb.currentShaderTime;
				t1 = t1 - floor( t1 );
				t2 = t2 - floor( t2 );
				Matrix4_Translate2D( result, t1, t2 );
				break;
			case TC_MOD_TRANSFORM:
				m2[0] = tcmod->args[0], m2[1] = tcmod->args[2], m2[12] = tcmod->args[4],
				m2[5] = tcmod->args[1], m2[4] = tcmod->args[3], m2[13] = tcmod->args[5];
				Matrix4_Copy2D( result, m1 );
				Matrix4_Multiply2D( m2, m1, result );
				break;
			default:
				break;
		}
	}
}

/*
* RB_UpdateCommonUniforms
*/
static void RB_UpdateCommonUniforms( int program, const shaderpass_t *pass, mat4_t texMatrix ) {
	vec3_t entDist, entOrigin;
	byte_vec4_t constColor;
	float colorMod = 1.0f;
	const entity_t *e = rb.currentEntity;
	vec3_t tmp;
	vec2_t blendMix = { 0, 0 };

	// the logic here should match R_TransformForEntity
	if( e->rtype != RT_MODEL ) {
		VectorClear( entOrigin );
		VectorCopy( rb.cameraOrigin, entDist );
	} else {
		VectorCopy( e->origin, entOrigin );
		VectorSubtract( rb.cameraOrigin, e->origin, tmp );
		Matrix3_TransformVector( e->axis, tmp, entDist );
	}

	// calculate constant color
	RB_GetShaderpassColor( pass, constColor, &colorMod );

	// apply modifications to texture coordinates
	if( pass->numtcmods ) {
		RB_ApplyTCMods( pass, texMatrix );
	}

	RP_UpdateViewUniforms( program,
		rb.objectMatrix,
		rb.modelviewMatrix, rb.modelviewProjectionMatrix,
		rb.cameraOrigin, rb.cameraAxis,
		rb.gl.viewport,
		rb.zNear, rb.zFar
	);

	if( RB_IsAlphaBlending( rb.gl.state & GLSTATE_SRCBLEND_MASK, rb.gl.state & GLSTATE_DSTBLEND_MASK ) ) {
		blendMix[1] = 1;
		if( rb.alphaHack ) {
			constColor[3] *= rb.hackedAlpha;
		}
	} else {
		blendMix[0] = 1;
		if( rb.alphaHack ) {
			constColor[0] *= rb.hackedAlpha, constColor[1] *= rb.hackedAlpha, constColor[2] *= rb.hackedAlpha;
		}
	}

	RP_UpdateShaderUniforms( program,
		rb.currentShaderTime,
		entOrigin, entDist, rb.entityColor,
		constColor,
		pass->rgbgen.func.type != SHADER_FUNC_NONE ? pass->rgbgen.func.args : pass->rgbgen.args,
		pass->alphagen.func.type != SHADER_FUNC_NONE ? pass->alphagen.func.args : pass->alphagen.args,
		texMatrix, colorMod );

	RP_UpdateBlendMixUniform( program, blendMix );

	RP_UpdateSoftParticlesUniforms( program, r_soft_particles_scale->value );

	if( rsh.worldBrushModel != NULL ) {
		RP_UpdateMapUniforms( program, rsh.worldBrushModel->fogStrength );
	}
}

/*
* RB_RenderMeshGLSL_Q3AShader
*/
static void RB_RenderMeshGLSL_Q3AShader( const shaderpass_t *pass, r_glslfeat_t programFeatures ) {
	int state;
	int program;
	int rgbgen = pass->rgbgen.type;
	const image_t *image;
	bool isWorldSurface = rb.currentModelType == mod_brush;
	bool isWorldVertexLight = false;
	bool applyLighting;
	vec3_t lightDir;
	vec4_t lightAmbient, lightDiffuse;
	mat4_t texMatrix, genVectors;
	bool noDlight = ( rb.surfFlags & SURF_NODLIGHT ) != 0;

	if( isWorldSurface ) {
		if( rb.mode == RB_MODE_DIFFUSE ) {
			return;
		}

		isWorldVertexLight = !noDlight;
	}

	// diffuse lighting for entities
	VectorSet( lightDir, 0, 0, 0 );
	Vector4Set( lightAmbient, 1, 1, 1, 1 );
	Vector4Set( lightDiffuse, 1, 1, 1, 1 );

	image = RB_ShaderpassTex( pass );
	if( rb.triangleOutlines || rb.mode == RB_MODE_DECALS ) {
		applyLighting = false;
	} else {
		applyLighting = isWorldVertexLight;
	}

	if( !applyLighting && rb.mode == RB_MODE_DIFFUSE ) {
		return;
	}
	if( applyLighting && rb.mode == RB_MODE_POST_LIGHT ) {
		return;
	}

	if( applyLighting ) {
		if( DRAWFLAT() ) {
			programFeatures |= GLSL_SHADER_COMMON_DRAWFLAT | GLSL_SHADER_COMMON_FOG;
		}
	}

	if( image->flags & IT_ALPHAMASK ) {
		programFeatures |= GLSL_SHADER_Q3_ALPHA_MASK;
	}

	// convert rgbgen and alphagen to GLSL feature defines
	programFeatures |= RB_RGBAlphaGenToProgramFeatures( &pass->rgbgen, &pass->alphagen );

	programFeatures |= RB_TcGenToProgramFeatures( pass->tcgen, pass->tcgenVec, texMatrix, genVectors );

	// set shaderpass state (blending, depthwrite, etc)
	state = pass->flags;

	if( isWorldVertexLight && !rb.doneDepthPass && !( state & GLSTATE_DEPTHWRITE ) && Shader_DepthWrite( rb.currentShader ) ) {
		if( !( pass->flags & SHADERPASS_ALPHAFUNC ) ) {
			state &= ~GLSTATE_BLEND_MASK;
		}
		state |= GLSTATE_DEPTHWRITE;
	}

	RB_SetState( RB_GetShaderpassState( state ) );

	RB_BindImage( 0, image );

	if( programFeatures & GLSL_SHADER_COMMON_SOFT_PARTICLE ) {
		RB_BindImage( 3, rb.st.screenDepthTexCopy );
	}

	RB_BindImage( 7, rsh.blueNoiseTexture );

	// update uniforms
	program = RB_RegisterProgram( GLSL_PROGRAM_TYPE_Q3A_SHADER, NULL,
								  rb.currentShader->deformsKey, rb.currentShader->deforms, rb.currentShader->numdeforms, programFeatures );
	if( RB_BindProgram( program ) ) {
		RB_UpdateCommonUniforms( program, pass, texMatrix );

		RP_UpdateTexGenUniforms( program, genVectors );

		if( isWorldSurface || rgbgen == RGB_GEN_LIGHTING_DIFFUSE ) {
			RP_UpdateDiffuseLightUniforms( program, lightDir, lightAmbient, lightDiffuse );
		}

		// submit animation data
		if( programFeatures & GLSL_SHADER_COMMON_SKINNED ) {
			RP_UpdateSkinningUniforms( program, rb.skinning_matrices );
		}

		// r_drawflat
		if( programFeatures & GLSL_SHADER_COMMON_DRAWFLAT ) {
			RP_UpdateDrawFlatUniforms( program, rsh.wallColor, rsh.floorColor );
		}

		if( programFeatures & GLSL_SHADER_COMMON_SOFT_PARTICLE ) {
			RP_UpdateTextureUniforms( program,
									  rb.st.screenDepthTex->upload_width, rb.st.screenDepthTex->upload_height );
		}

		RB_DrawElementsReal( &rb.drawElements );
	}
}
